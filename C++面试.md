# C++面试题总结

## Content

[1.数据类型]（#1数据类型）


## 1. 数据类型

### 1. const

1. const和#define相比的优点？

   - 可以指定数据类型
   - 可以使用C++的作用域规则
   - 可以用于更复杂的类型如数组和结构

2. const 指针？

   - 指向const的指针

     ```c++
     int const *p;
     const int *p;
     ```

     p的内容不能改变，但p可以指向别的指针
     
   - const修饰指针
   
     ```c++
     int *const p;
     ```
   
     p不能指向别的内容，但可以修改指向的内容
   
3. const修饰函数传入参数？

   函数将不能修改该参数或该参数所指向的对象

4. const修饰函数返回值？

   用户不能修改返回值，返回值必须赋给常变量或常指针。

5. const修饰成员函数？

   ```C++
   void func() const{};
   ```

   - const对象只能访问const成员函数，非const对象可以访问任意成员函数
   - const对象的成员不能修改
   - const成员函数不能修改对象的数据

6. const可以不初始化吗？

   const对象初始化后无法改变，因此必须初始化

7. const作用域？

   const对象通常只在本文件内有效，如希望其在其他文件也有效，需要加extern关键字。即在一个文件中定义const，在其他多个文件中声明并使用。

### 2. 类型转换

1. 静态 static_cast

   ```c++
   static_cast<type-id> (expression);
   ```

   编译时期的静态类型检测，强制转换，没有类型检查，不安全

   用于：

   - 基类和子类之间的转换，子类指针转父类指针安全（上行），父类指针转子类不安全（下行）。不能进行无关类型指针之间的转换。
   - 基本数据类型转换。
   - 空指针转换为目标类型的空指针
   - 任何类型的表达式转换为void类型
   - 不能去掉类型的const、volitale属性

   主要执行非多态的转换操作，建议替换所有隐式转换

2. 动态 dynamic_cast

   ```c++
   dynamic_cast<type-id> (expression)
   ```

   运行时的动态类型检测，转换失败返回NULL；不支持基础类型转换

   用于：

   - 安全的向下转换（父类转为子类）（也可以向上转换，但没必要，因为可以用虚函数实现）
   - 父类中必须有虚函数保证多态，才能使用动态转换