# C++面试题总结

## Content

[1. 数据类型](#1数据类型)


## 1. 数据类型

### 1. const

1. const和#define相比的优点？

   - 可以指定数据类型
   - 可以使用C++的作用域规则
   - 可以用于更复杂的类型如数组和结构

2. const 指针？

   - 指向const的指针

     ```c++
     int const *p;
     const int *p;
     ```

     p的内容不能改变，但p可以指向别的内容
     
   - const修饰指针
   
     ```c++
     int *const p;
     ```
   
     p不能指向别的内容，但可以修改指向的内容
   
3. const修饰函数传入参数？

   函数将不能修改该参数或该参数所指向的对象

4. const修饰函数返回值？

   用户不能修改返回值，返回值必须赋给常变量或常指针。

5. const修饰成员函数？

   ```C++
   void func() const{};
   ```

   - const对象只能访问const成员函数，非const对象可以访问任意成员函数
   - const对象的成员不能修改
   - const成员函数不能修改对象的数据

6. const可以不初始化吗？

   const对象初始化后无法改变，因此必须初始化

7. const作用域？

   const对象通常只在本文件内有效，如希望其在其他文件也有效，需要加extern关键字。即在一个文件中定义const，在其他多个文件中声明并使用。

### 2. 类型转换

1. 静态 static_cast

   ```c++
   static_cast<type-id> (expression);
   ```

   编译时期的静态类型检测，强制转换，没有类型检查，不安全

   用于：

   - 基类和子类之间的转换，子类指针转父类指针安全（上行），父类指针转子类不安全（下行）。不能进行无关类型指针之间的转换。
   - 基本数据类型转换。
   - 空指针转换为目标类型的空指针
   - 任何类型的表达式转换为void类型
   - 不能去掉类型的const、volitale属性

   主要执行非多态的转换操作，建议替换所有隐式转换

2. 动态 dynamic_cast

   ```c++
   dynamic_cast<type-id> (expression)
   ```

   运行时的动态类型检测，转换失败返回NULL；不支持基础类型转换

   用于：

   - 安全的向下转换（父类转为子类）（也可以向上转换，但没必要，因为可以用虚函数实现）
   - 父类中必须有虚函数保证多态，才能使用动态转换，否则转换失败。
   - 多重继承情况下，用于派生类的多个基类之间的相互转换
   
3. const_cast

   主要用于解除常指针和常引用的const和volatile属性

4. reinterpret_cast

   一般不建议使用。用于将指针转换为其他类型指针，也允许将指针转化为整数类型。可以在非相关的类型之间进行，在确保安全的情况下可以适当使用。

5. 什么是强制类型转换？

   相当于一次函数调用，结果是生成了一个新的数据实体，或者生成一个指向原数据实体但解释方式发生变化的指针（或引用）

6. 强制类型转换的安全性？

   使用静态类型转换时的安全需要由程序员保证，使用动态类型转换时编译器会动态检查转换的安全性。

7. 动态类型转换的安全性？

   动态类型转换只能用于有继承关系的类之间的类型转换，当进行安全的向上转换时（子类转父类），与静态转换相同；当进行乡下转换时，运行时动态检查，依赖于对象的RTTI（Run-Time Type Information）通过虚函数表找到RTTI确定基类指针所指对象的真实类型来确定是否能进行转换。

8. const_cast能将变量转换为非const吗？

   只能用于去除指针或引用的const或volatile属性，变量本身的属性不能被去除。
